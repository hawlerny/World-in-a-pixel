<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>World in a Pixel - Launcher</title>
  <style>
    body {
      background-color: black;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      font-family: monospace;
      color: #0f0;
      overflow: hidden;
      user-select: none;
    }

    #container {
      position: relative;
      width: 700px;
      height: 700px;
      background-color: #0b0b0b;
      border: 2px solid #004400;
      overflow: hidden;
    }

    #codeRainCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
      background: transparent;
    }

    #titleArea {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 25%;
      border-bottom: 2px solid #003300;
      overflow: hidden;
      z-index: 2;
    }

    #gameTitle {
      position: absolute;
      top: 0;
      left: 0;
      font-size: 3rem;
      font-weight: bold;
      color: #00ff00;
      text-shadow:
        0 0 3px #39ff14,
        0 0 6px #39ff14,
        0 0 10px #39ff14,
        0 0 20px #0fa,
        0 0 40px #0fa;
      user-select: none;
      z-index: 3;
      pointer-events: none;
      white-space: nowrap;
    }

    #launchText {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 2rem;
  font-weight: bold;
  color: #00ff00;
  text-shadow:
    0 0 3px #39ff14,
    0 0 6px #39ff14,
    0 0 10px #39ff14,
    0 0 20px #0fa,
    0 0 40px #0fa;
  display: none;
  z-index: 4;
  user-select: none;
  pointer-events: none;
  max-width: 90%;
  text-align: center;

  /* Add these: */
  white-space: normal;  /* Allow line breaks */
  justify-content: center;  /* vertical centering */
  align-items: center;      /* horizontal centering */
  height: auto;             /* adjust height automatically */
  padding: 10px;            /* optional padding */
}


    #startButton {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #0a0;
      color: black;
      border: none;
      padding: 10px 20px;
      font-size: 20px;
      cursor: pointer;
      z-index: 2;
      user-select: none;
    }

    #loadingBarContainer {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      height: 20px;
      background-color: #003300;
      border: 1px solid #00ff00;
      display: none;
      z-index: 2;
    }

    #loadingBar {
      height: 100%;
      width: 0;
      background-color: #00ff00;
    }
	#countdownContainer {
  font-size: 2.5rem;
  display: block;
  margin-top: 10px;
}

#smallNote {
  font-size: 0.8rem;
  color: #0f0;
  opacity: 0.7;
  display: block;
  margin-top: 5px;
}

  </style>
</head>
<body>
  <div id="container">
    <canvas id="codeRainCanvas" width="700" height="700"></canvas>

    <div id="titleArea">
      <div id="gameTitle">World in a Pixel</div>
    </div>

    <div id="launchText">
  Redirecting in<br>
  <span id="countdownContainer">
    <span id="countdown">3</span><br>
    <span id="smallNote">Close this window if it does not close automatically</span>
  </span>
</div>


    <button id="startButton">Start Game</button>
    <div id="loadingBarContainer">
      <div id="loadingBar"></div>
    </div>
  </div>

  <script>
    const title = document.getElementById("gameTitle");
    const titleArea = document.getElementById("titleArea");
    const startButton = document.getElementById("startButton");
    const loadingBar = document.getElementById("loadingBar");
    const loadingBarContainer = document.getElementById("loadingBarContainer");
    const launchText = document.getElementById("launchText");
    const canvas = document.getElementById("codeRainCanvas");
    const ctx = canvas.getContext("2d");

    let loading = false;

    // Title animation vars
    let titleX = 0;
    let titleY = 0;
    let velocityX = 0.7;
    let velocityY = 0.2;
    let blinkOpacity = 1;
    let blinkDirection = -1;

    let lastFrameTime = performance.now();

    function animateTitle() {
      const currentFrameTime = performance.now();
      const deltaTime = (currentFrameTime - lastFrameTime) / 1000; // Convert to seconds
      lastFrameTime = currentFrameTime;

      titleX += velocityX * deltaTime * 60; // Scale by 60 to match previous behavior
      titleY += velocityY * deltaTime * 60;

      const maxX = titleArea.clientWidth - title.offsetWidth;
      const maxY = titleArea.clientHeight - title.offsetHeight;

      if (titleX <= 0) {
        velocityX *= -1;
        titleX = 0;
      } else if (titleX >= maxX) {
        velocityX *= -1;
        titleX = maxX;
      }

      if (titleY <= 0) {
        velocityY *= -1;
        titleY = 0;
      } else if (titleY >= maxY) {
        velocityY *= -1;
        titleY = maxY;
      }

      title.style.left = titleX + "px";
      title.style.top = titleY + "px";

      blinkOpacity += blinkDirection * 0.0028 * deltaTime * 60;
      if (blinkOpacity >= 1) blinkDirection = -1;
      else if (blinkOpacity <= 0.3) blinkDirection = 1;

      title.style.opacity = blinkOpacity;

      if (!loading) {
        requestAnimationFrame(animateTitle);
      }
    }
    animateTitle();

    // Ensure the title spawns at a random location within its container on each page load
    function setRandomTitlePosition() {
      // Wait for the browser to fully render the title element
      requestAnimationFrame(() => {
        const maxX = titleArea.clientWidth - title.offsetWidth;
        const maxY = titleArea.clientHeight - title.offsetHeight;

        const randomX = Math.random() * maxX;
        const randomY = Math.random() * maxY;

        title.style.left = randomX + "px";
        title.style.top = randomY + "px";
      });
    }

    // Call the function to set the random position after the DOM has fully loaded
    window.addEventListener("load", () => {
      const maxX = titleArea.clientWidth - title.offsetWidth;
      const maxY = titleArea.clientHeight - title.offsetHeight;
      const randomX = Math.random() * maxX;
      const randomY = Math.random() * maxY;
      titleX = randomX;
      titleY = randomY;
      title.style.left = `${titleX}px`;
      title.style.top = `${titleY}px`;
    });

    // Code rain setup
    const fontSize = 16;
    const columns = Math.floor(canvas.width / fontSize);

    // Characters used for rain: 3/4 '0' or '1', 1/4 Japanese Katakana (some common symbols)
    const binaryChars = ["0", "1"];
    const japaneseChars = ["ｱ", "ｲ", "ｳ", "ｴ", "ｵ", "ｶ", "ｷ", "ｸ", "ｹ", "ｺ"];

    // Drops for the rain, each column holds an array of characters
    let drops = [];
    for (let i = 0; i < columns * 1.5; i++) { // Increase the number of columns by 50%
      drops[i] = {
        y: Math.random() * -canvas.height, // Stagger starting positions randomly above the canvas
        x: (i % columns) * fontSize + (Math.random() - 0.5) * fontSize, // Add random horizontal offset to break grid alignment
        chars: Array.from({ length: Math.floor(canvas.height / fontSize / 2) }, getRandomChar), // Reduce density by halving the number of characters
      };
    }

    function getRandomChar() {
      // 60% chance binary, 40% chance japanese
      if (Math.random() < 0.60) {
        return binaryChars[Math.floor(Math.random() * binaryChars.length)];
      } else {
        return japaneseChars[Math.floor(Math.random() * japaneseChars.length)];
      }
    }

    let rainRunning = false;

    function startCodeRain() {
      if (rainRunning) return;
      rainRunning = true;
      ctx.font = fontSize + "px monospace";

      let lastUpdateTime = performance.now();
      let initialDelay = 0.5; // Fixed delay of 0.5 seconds for columns to start appearing
      let initialColumns = Math.floor(6 + Math.random() * 6); // Random starting number of columns (6 to 12)
      let columnIncrement = Math.ceil(initialColumns / 4); // Number of columns added every 0.5 seconds
      let maxColumns = columns * 3; // Cap at 300% of initial columns for stability

      function draw() {
        const currentFrameTime = performance.now();
        const deltaTime = (currentFrameTime - lastUpdateTime) / 1000; // Convert to seconds
        const elapsedTime = (currentFrameTime - lastUpdateTime) / 1000; // Time since last update
        lastUpdateTime = currentFrameTime;

        ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let i = 0; i < drops.length; i++) {
          let drop = drops[i];

          // Draw the column of characters
          for (let j = 0; j < drop.chars.length; j++) {
            const textY = (drop.y + j) * fontSize;
            if (textY > canvas.height) continue; // Skip characters below the canvas

            ctx.fillStyle = "#0f0"; // All characters are green
            ctx.fillText(drop.chars[j], drop.x, textY);
          }

          // Move the column down
          drop.y += 0.6 * deltaTime * 60; // Scale by 60 to match previous behavior

          // Reset the column when it moves off the screen
          if (drop.y * fontSize > canvas.height) {
            drop.y = Math.random() * -canvas.height - canvas.height * 0.5; // Reset to a random position above the canvas
            drop.chars = Array.from({ length: Math.floor(1 + Math.random() * 25) }, getRandomChar); // Randomize number of characters (1 to 25)
          }
        }

        // Update the number of columns over time
        if (elapsedTime > initialDelay) {
          updateRainColumns(elapsedTime - initialDelay, initialColumns, columnIncrement, maxColumns);
        }
        lastUpdateTime = currentFrameTime;

        requestAnimationFrame(draw);
      }
      draw();
    }

    function updateRainColumns(elapsedTime, initialColumns, columnIncrement, maxColumns) {
      // Gradually increase the number of columns every 0.5 seconds
      const targetColumns = Math.min(maxColumns, initialColumns + Math.floor(elapsedTime / 0.5) * columnIncrement);

      // Add new columns if needed without resetting existing ones
      while (drops.length < targetColumns) {
        drops.push({
          y: Math.random() * -canvas.height - canvas.height * 0.5, // Start slightly above the window
          x: (drops.length % columns) * fontSize + (Math.random() - 0.5) * fontSize, // Add random horizontal offset to break grid alignment
          chars: Array.from({ length: Math.floor(1 + Math.random() * 25) }, getRandomChar), // Randomize number of characters (1 to 25)
        });
      }
    }

    startButton.addEventListener("click", () => {
      startButton.style.display = "none";
      loadingBarContainer.style.display = "block";
      loading = true;

      let progress = 0;
      const loadingInterval = setInterval(() => {
        // Adjust loading speed dynamically
        if (progress < 10) {
          progress += 2; // Faster at the start
        } else if (progress < 90) {
          progress += 0.5; // Normal speed
        } else {
          progress += 0.2; // Slower near the end
        }

        loadingBar.style.width = progress + "%";

        // Update rain columns based on progress
        updateRainColumns(progress);

        if (progress >= 100) {
          clearInterval(loadingInterval);
          launchText.style.display = "block";
          let count = 3;
          const countdownEl = document.getElementById("countdown");
countdownEl.textContent = count;
const countdown = setInterval(() => {
  count--;
  countdownEl.textContent = count;
  if (count === 0) clearInterval(countdown);
}, 1000);

          loadingBarContainer.style.display = "none";
          setTimeout(() => {
            window.location.href = "core.html";
          }, 3000);
        }
      }, 56); // 40% slower (40ms -> 56ms)

      // Start rain immediately on button click
      startCodeRain();
    });
  </script>
</body>
</html>
